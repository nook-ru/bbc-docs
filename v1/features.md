# Возможности

## Уведомление об ошибках

ББК построен на использовании исключений, что позволяет контролировать ход выполнения компонента и в случае непредвиденной ситуации корректно её обрабатывать. Если компонент не может продолжать свою работу, нужно выбросить исключение (`throw new Exception()`), которое будет перехвачено и обработано.

Перехваченные исключения ББК обрабатывает, выводит соответствующее сообщение пользователю и отправляет (если в этом есть необходимость) уведомление на почту администратора сайта.

Методы обработки исключений находятся в трейте Common (подключается автоматически во всех компонентах ББК). Перечислим их.

Метод | Описание
-------------- | --------------
`catchException()` | «Ловит» исключения, останавливает и отменяет кеширование, вызывает соответствующие методы для отображения сообщения об ошибке и отправке уведомления администратору
`showExceptionUser()` | Выводит сообщение об ошибке простому пользователю
`showExceptionAdmin()` | Выводит сообщение об ошибке и дебаг исключения, если пользователь является администратором
`sendNotifyException()` | Отправляет сообщение об ошибке на почту администратора сайта

По-умолчанию сообщения об ошибках отправляются всегда, кроме случая, когда исключение выброшено по причине отсутствия данных (статус 404). Отключить отправку уведомлений можно двумя способами:

## Подключение модулей

Воспользуйтесь свойством класса `$this->needModules`, если для работы компонента необходимо подключение модулей. Обратите внимание: если родительским классом не является `Basis` или `BasisRouter`, что бы не потерять родительские настройки, свойство необходимо дополнять, а не переназначать.

Свойство `$this->needModules` является массивом, значения которого — коды модулей (`iblock`, `seo`, `catalog` и т. д.).

```php
<?php

class TestChild extends TestParent
{
	public function onPrepareComponentParams($params)
	{
		// Дополним свойство needModules, что бы не потерять настройки родительского класса
		// Подключаем модули веб-формы и поиск
		$this->needModules = array_unique(array_merge($this->needModules, ['form', 'search']));

		return parent::onPrepareComponentParams($params);
	}
}
```

Модули подключаются перед вызовом метода `executeProlog()`. В случае ошибки подключения модуля выбрасывается исключение.

## Параметры компонента

### Проверка и приведение

ББК значительно упрощает и ускоряет работу с параметрами компонента. Если раньше нужно было вручную производить приведение типов и проверку переданных компоненту параметров, теперь ББК делает это самостоятельно, на основании свойства класса `$checkParams`.

```php
<?php

class Test extends Basis
{
	protected $checkParams = [
		'IBLOCK_TYPE' => ['type' => 'string'],
	    'IBLOCK_ID' => ['type' => 'int'],
	    'SECTION_ID' => ['type' => 'int', 'error' => false],
	    'ELEMENT_ID' => ['type' => 'int', 'error' => '404']
	];
}
```

`$checkParams` должен содержать массив, ключами которого являются коды параметров компонентов (которые нужно обработать), а значениями — массив с правилами обработки.

В правилах обработки можно указывать:

* `type` — тип приведения
	* `int`
	* `string`
	* `array`
* `error` — что делать, если значение параметра пустое или не соответствует указанному в type типу (по-умолчанию выбрасывается исключение `\Bitrix\Main\ArgumentTypeException`)
	* `false` — ничего
	* `404` — выбросить исключение и установить 404-й ХТТП-статус

Если родительским классом не является `Basis` или `BasisRouter`, важно помнить, что в нём может (уже или в будущем) быть установлено свойство `$checkParams`. Поэтому, что бы не потерять родительские настройки, свойство необходимо дополнять, а не переназначать.

```php
<?php

class TestChild extends TestParent
{
	public function onPrepareComponentParams($params)
	{
		// Дополним свойство checkParams, что бы не потерять настройки родительского класса
		$this->checkParams += [
			'TITLE' => ['type' => 'string', 'error' => false]
		];

		return parent::onPrepareComponentParams($params);
	}
}
```

Проверка и приведение параметров производится перед вызовом метода `executeProlog()`.

### Наследование


## Работа с аяксом

Немного теории. Аякс-запросы можно организовать двумя способами.

Способ | Минусы | Плюсы
-------------- | -------------- | --------------
Отдельный файл с подключением пролога и необходимого компонента | Нужно дважды прописывать параметры компонента | Более высокая скорость
Та же самая страница, на которой размещён компонент при работе в обычном (не аяксовом) режиме | При аякс-запросах исполняется вся страница | Простота поддержки: параметры компонента настраиваются в одном месте

В ББК реализована обработка аякс-запросов вторым способом: когда запрос посылается на ту же страницу, где размещён компонент в обычном режиме. Клиент должен послать запрос на страницу, передав идентификатор компонента, сообщающий системе, с каким компонентом нужно работать в данном запросе. Эти параметры доступны в шаблоне в переменной `$arResult`.

```php
<?php

// Строка вида compid=p62vhc634vx2ja8 — её необходимо передавать вместе с GET-запросом
$arResult['AJAX_REQUEST_PARAMS']
```

```html
// Если аякс-запрос осуществляется методом POST (например, отправка формы), идентификатор можно передать через скрытый инпут
<input type="hidden" name="<?=$arResult['AJAX_PARAM_NAME']?>" value="<?=$arResult['AJAX_COMPONENT_ID']?>" />
```

### Что происходит при аякс-запросе?

Когда компонент обнаруживает, что к нему осуществляется аякс-запрос, перед началом вывода (до вызова метода `executeProlog()`) и после подключения шаблона (после вызова метода `executeEpilog()`) он очищает буфер вывода. Таким образом, компонент вернёт только то, что будет выведено в его шаблоне (или методах `executeProlog()`, `executeMain()` и `executeEpilog()`).

### Кастомизация

ББК довольно гибкие: они позволяют задавать свой идентификатор компонента, если в этом есть необходимость. Собственный айди устанавливается в параметре `AJAX_COMPONENT_ID`. Это может пригодится, когда мы хотим сформировать гиперссылку для аякса за пределами компонента (т. е., мы не имеем доступа к сгенерированному идентификатору).

```php
<?php

$this->arParams['AJAX_COMPONENT_ID'] = 'my_test_id';
```

Если вдруг параметр `compid` (`compid=идентификато-компонента`) где-то используется у вас на сайте, его название можно так же изменить.

```php
<?php

$this->arParams['AJAX_PARAM_NAME'] = 'comp_ajax_id';
```

По-умолчанию компоненты подключают в качестве шаблона файл `template.php`. Для аякс-запросов можно отдавать другой файл, находящийся в той же директории. Для этого достаточно указать имя файла (без расширения) в параметре `AJAX_TEMPLATE_PAGE`.

```php
<?php

// Для аякс-запросов вместо template.php будет отдаваться ajax.php
$this->arParams['AJAX_TEMPLATE_PAGE'] = 'ajax';
```

### Режимы

В аяксе поддерживается два варианта ответов: обычный ХТМЛ и джейсон. Режим устанавливается в параметре компонента `AJAX_TYPE`.

```php
<?php

$this->arParams['AJAX_TYPE'] = 'JSON';
```

### Перезагрузка заголовков

В аякс-режиме после сброса буфера, но до вывода результатов исполнения компонента, ББК может перезагружать заголовки страницы (подключать ЯС, ЦСС и т. д.). По-умолчанию перезагрузка отключена. Для включения установите параметр `AJAX_HEAD_RELOAD = Y`.

```php
<?php

$this->arParams['AJAX_HEAD_RELOAD'] = 'Y';
```

### Например

Рассмотрим пример реализации типичного запроса данных по аяксу.

1.&nbsp;Укажем в настройках компонента (параметр `AJAX_TEMPLATE_PAGE`), что в аякс-режиме необходимо работать с файлом шаблона `ajax.php`.

2.&nbsp;Создадим шаблон для обычного режима (`template.php`).

```html
<h1>Я — простой шаблон</h1>

<a href="#" class="js-ajax" data-ajax-params="<?=$arResult['AJAX_REQUEST_PARAMS']?>">Подгрузить данные аяксом</a>

<div id="ajax-block">
</div>
```

3.&nbsp;И для аякс-режима (`ajax.php`).

```html
А я аякс!
```

4.&nbsp;А также файл `script.js`, в котором с помощью «Джейквери» (подразумевается, что на сайте она установлена) будем осуществлять аякс-запрос.

```javascript
// script.js
$(document).on('click', '.js-ajax', function() {
	$.ajax({
		data: $(this).data('ajaxParams'),
		success: function (response) {
			$('#ajax-block').html(response);
		}
	});
});
```

Готово. Теперь при клике на ссылку «Подгрузить данные аяксом» текущему компоненту будет отправляться аякс-запрос. Компонент вернёт ответ, используя в качестве шаблона файл `ajax.php`.

<aside class="notice">
    В компоненте <code>elements.list</code> параметры аякса (идентификатор, страница шаблона, перезагрузка заголовков и режим) вынесены в настройки компонента (<code>.parameters.php</code>).
</aside>

## Кеширование

Компонент кешируется автоматически, если ему передать соответствующие параметры `CACHE_TYPE` и `CACHE_TIME`. Кешируется только метод `executeMain()` и шаблон. Если кеширование шаблона необходимо отключить, нужно установить свойство класса `cacheTemplate` в значение `false`.

```php
<?php

class Test extends Basis
{
	// Отключаем кеширование шаблона компонента. 
	// Метод executeMain() по-прежнему будет кешироваься 
	// (если установлены параметры CACHE_TYPE и CACHE_TIME)
	protected $cacheTemplate = false;
}
```

В ББК существует метод-хэлпер `registerCacheTag($tag)`, который помечает кеш тегом. Пометив кеш, в будущем мы сможем сбросить его по тегу `$tag` с помощью `\Bitrix\Main\Application::getInstance()->getTaggedCache()->clearByTag($tag)`. 

<aside class="notice">
    Тег кеша устанавливается и сбрасывается автоматически, если в кешируемой области (в данном случае таковой является метод <code>executeMain()</code>) происходит обращение к инфоблоку через <code>CIBlockElement::GetList()</code>. <code>GetList()</code> обязательно должен возвращать идентификатор инфоблока (поле <code>IBLOCK_ID</code>). В компонентах <code>elements.list</code> и <code>element.detail</code> кеш помечается и сбрасывается автоматически.
</aside>

ББК может разделять кеш для разных групп пользователей. Для этого установите параметр компонента `CACHE_GROUPS = Y`. Вы так же можете добавить дополнительный идентификатор кеша с помощью метода `addCacheAdditionalId($id)`.

```php
<?php

// Пусть кеш реагирует на значение переменной $dependentVar
$this->addCacheAdditionalId($dependentVar);
```

Директорию хранения кеша можно задать в свойстве класса компонента `$this->cacheDir`. По-умолчанию «Битрикс» самостоятельно формирует путь.

ББК предоставляет сл. методы-хэлперы для работы с кешом.

Авт. | Метод | Описание
-------------- | -------------- | --------------
+ | `startCache()` | Подготовка параметров и начало кеширования. Возвращает `true`, если кеш существует и выполнять вычисления не нужно, в противном случае — `false`
+ | `writeCache()` | Завершает кеширование
- | `abortCache()` | Отмена кеширования
 
## Поисковая оптимизация

### Мета-теги

### Короткие ссылки

### Хлебные крошки

## Управление контентом

### Постраничная навигация

Генерация постраничной навигации реализуется трейтом `Elements`. Параметры компонента, влияющие на генерацию:

Параметр | Описание
-------------- | -------------- | --------------
`DISPLAY_TOP_PAGER` | Выводить строку в начале шаблона
`DISPLAY_BOTTOM_PAGER` | Выводить строку внизу шаблона
`ELEMENTS_COUNT` | Кол-во элементов на странице
`PAGER_DESC_NUMBERING` | Постраничная навигация в обратном порядке
`PAGER_SHOW_ALL` | Разрешить отображение всех записей на одной странице
`PAGER_SAVE_SESSION` | Записывать в сессию номер текущей страницы (по-умолчанию выкл.)
`PAGER_TITLE` | Заголовок для строки
`PAGER_TEMPLATE` | Шаблон строки постраничной навигации
`PAGER_SHOW_ALWAYS` | Показывать строку всегда (по-умолчанию выкл.)

Вывод строки постраничной навигации в шаблоне производится через элемент массива arResult:

```php
<div>
	<?=$arResult['NAV_STRING']?>
</div>
```

### «Эрмитаж»
Функционал «Эрмитажа» реализуется трейтом `Elements`. Просто подключите его.
